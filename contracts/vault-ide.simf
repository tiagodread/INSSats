/*
 * INSSats Vault Contract - IDE Online Format
 *
 * Para usar em: https://simfony.dev/
 */

mod witness {
    // Empty witness for create_vault (no signatures needed, just validation)
}

mod param {
    // Vault participant public keys
    const SAVER_PUBKEY: u256 = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798;
    const BROKER_PUBKEY: u256 = 0xc6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5;
    const KEEPER_PUBKEY: u256 = 0xf9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9;

    // Fee structure
    const BROKER_FEE_BP: u32 = 250;        // 2.5% = 250 basis points
    const URGENT_FEE: u64 = 5000;          // 5000 satoshis

    // Timelock periods (in blocks)
    const PLANNED_TIMELOCK: u32 = 10080;   // ~7 days (1 block/min on Liquid)
    const URGENT_TIMELOCK: u32 = 1440;     // ~1 day
    const KEY_RECOVERY_TIMELOCK: u32 = 43200;  // ~30 days
    const PARAMS_CHANGE_TIMELOCK: u32 = 20160; // ~14 days
}

// ============================================================================
// Helper Functions
// ============================================================================

// Get current block height
fn get_current_height() -> u32 {
    jet::current_index()
}

// ============================================================================
// create_vault - Create new vault configuration
// ============================================================================
fn create_vault(
    saver: u256,
    broker: u256,
    keeper: u256,
    broker_fee_bp: u32,
    urgent_fee: u64,
    planned_timelock: u32,
    urgent_timelock: u32,
    key_recovery_timelock: u32,
    params_change_timelock: u32
) -> (u256, u256, u256, u32, u64, u32, u32, u32, u32, u64, u32) {

    // TODO: Validate unique keys (saver != broker != keeper)
    // Skipped for now due to bool/u1 type complexity
    // Will implement with proper pattern matching later

    // Validate fee range (0-10000 basis points = 0-100%)
    assert!(jet::le_32(broker_fee_bp, 10000));

    // Validate timelocks are positive
    // planned_timelock > 0
    assert!(jet::lt_32(0, planned_timelock));

    // urgent_timelock > 0
    assert!(jet::lt_32(0, urgent_timelock));

    // urgent_timelock <= planned_timelock
    assert!(jet::le_32(urgent_timelock, planned_timelock));

    // key_recovery_timelock > 0
    assert!(jet::lt_32(0, key_recovery_timelock));

    // params_change_timelock > 0
    assert!(jet::lt_32(0, params_change_timelock));

    // Build VaultConfig tuple
    let total_balance: u64 = 0;
    let created_at: u32 = get_current_height();

    // Return VaultConfig as 11-element tuple
    (
        saver,                      // .0
        broker,                     // .1
        keeper,                     // .2
        broker_fee_bp,              // .3
        urgent_fee,                 // .4
        planned_timelock,           // .5
        urgent_timelock,            // .6
        key_recovery_timelock,      // .7
        params_change_timelock,     // .8
        total_balance,              // .9
        created_at                  // .10
    )
}

// ============================================================================
// Main entry point
// ============================================================================
fn main() {
    // TODO: Validate unique keys (saver != broker != keeper)
    // Skipped for now - will implement with proper pattern matching later

    // Validate fee range (0-10000 basis points = 0-100%)
    assert!(jet::le_32(param::BROKER_FEE_BP, 10000));

    // Validate timelocks are positive
    assert!(jet::lt_32(0, param::PLANNED_TIMELOCK));
    assert!(jet::lt_32(0, param::URGENT_TIMELOCK));
    assert!(jet::le_32(param::URGENT_TIMELOCK, param::PLANNED_TIMELOCK));
    assert!(jet::lt_32(0, param::KEY_RECOVERY_TIMELOCK));
    assert!(jet::lt_32(0, param::PARAMS_CHANGE_TIMELOCK));
}
