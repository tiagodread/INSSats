/*
 * INSSats Vault Contract
 *
 * Flexible N-of-M multisig with timelock logic and consensus.
 * Implements a three-party system: Saver, Broker, and Vault Keeper.
 *
 * Based on: docs/TECHNICAL-IMPLEMENTATION.md
 */

// ============================================================================
// create_vault - Validate vault configuration parameters
// ============================================================================
fn create_vault(
    saver: u256,
    broker: u256,
    keeper: u256,
    broker_fee_bp: u32,
    urgent_fee: u64,
    planned_timelock: u32,
    urgent_timelock: u32,
    key_recovery_timelock: u32,
    params_change_timelock: u32
) {
    // Validate unique keys using match with block expressions
    // If keys are equal, force failure with impossible assertion
    match jet::eq_256(saver, broker) {
        true => { assert!(jet::lt_32(1, 0)); },  // Force failure if equal
        false => { assert!(jet::lt_32(0, 1)); }  // Always true - continue
    };

    match jet::eq_256(broker, keeper) {
        true => { assert!(jet::lt_32(1, 0)); },
        false => { assert!(jet::lt_32(0, 1)); }
    };

    match jet::eq_256(saver, keeper) {
        true => { assert!(jet::lt_32(1, 0)); },
        false => { assert!(jet::lt_32(0, 1)); }
    };

    // Validate fee range (0-10000 basis points = 0-100%)
    assert!(jet::le_32(broker_fee_bp, 10000));

    // Validate timelocks are positive
    assert!(jet::lt_32(0, planned_timelock));
    assert!(jet::lt_32(0, urgent_timelock));
    assert!(jet::le_32(urgent_timelock, planned_timelock));
    assert!(jet::lt_32(0, key_recovery_timelock));
    assert!(jet::lt_32(0, params_change_timelock));
}

// ============================================================================
// deposit - Deposit funds and calculate broker fee
// ============================================================================
fn deposit(
    current_balance: u64,
    amount: u64,
    broker_fee_bp: u32
) -> u64 {
    // Calculate broker fee: (amount * broker_fee_bp) / 10000
    // Approach: (amount / 10000) * broker_fee_bp
    // This loses some precision but avoids overflow

    // Step 1: Divide amount by 10000
    let amount_div_10k: u64 = jet::divide_64(amount, 10000);

    // Step 2: Multiply by broker_fee_bp using jet::multiply_32
    // jet::multiply_32(u32, u32) -> u64
    // Extract lower 32 bits of amount_div_10k (should always fit since we divided by 10000)
    let amount_div_u32: u32 = jet::rightmost_64_32(amount_div_10k);

    // Step 3: Calculate fee: amount_div_u32 * broker_fee_bp
    let fee: u64 = jet::multiply_32(amount_div_u32, broker_fee_bp);

    // Subtract fee from amount
    // jet::subtract_64 returns (bool, u64) where bool indicates underflow
    let (_, net_amount): (bool, u64) = jet::subtract_64(amount, fee);

    // Add to current balance
    // jet::add_64 returns (bool, u64) where bool indicates overflow
    let (_, new_balance): (bool, u64) = jet::add_64(current_balance, net_amount);

    new_balance
}

// ============================================================================
// operation - Route to create_vault or deposit based on operation type
// ============================================================================
fn operation(
    balance: u64,
    op: Either<
        (u256, u256, u256, u32, u64, u32, u32, u32, u32),  // CreateVault params
        (u64, u32)  // Deposit params: amount, broker_fee_bp
    >
) -> u64 {
    match op {
        Left(vault_params: (u256, u256, u256, u32, u64, u32, u32, u32, u32)) => {
            // CreateVault operation
            let (saver, broker, keeper, broker_fee_bp, urgent_fee,
                 planned_timelock, urgent_timelock,
                 key_recovery_timelock, params_change_timelock):
                (u256, u256, u256, u32, u64, u32, u32, u32, u32) = vault_params;

            create_vault(
                saver,
                broker,
                keeper,
                broker_fee_bp,
                urgent_fee,
                planned_timelock,
                urgent_timelock,
                key_recovery_timelock,
                params_change_timelock
            );
            balance
        },
        Right(deposit_params: (u64, u32)) => {
            // Deposit operation
            let (amount, broker_fee_bp): (u64, u32) = deposit_params;
            deposit(balance, amount, broker_fee_bp)
        }
    }
}

// ============================================================================
// Main entry point
// ============================================================================
fn main() {
    // Step 1: Create vault
    let balance_0: u64 = operation(
        0,
        Left((
            witness::SAVER_PUBKEY,
            witness::BROKER_PUBKEY,
            witness::KEEPER_PUBKEY,
            witness::BROKER_FEE_BP,
            witness::URGENT_FEE,
            witness::PLANNED_TIMELOCK,
            witness::URGENT_TIMELOCK,
            witness::KEY_RECOVERY_TIMELOCK,
            witness::PARAMS_CHANGE_TIMELOCK
        ))
    );
    // Step 2: First deposit - 100,000 sats
    // After 2.5% fee (2,500 sats): 97,500 sats
    let balance_1: u64 = operation(
        balance_0,
        Right((100000, witness::BROKER_FEE_BP))
    );
    assert!(jet::eq_64(balance_1, 97500));
    // Step 3: Second deposit - 50,000 sats
    // After 2.5% fee (1,250 sats): 48,750 sats
    // Total = 97,500 + 48,750 = 146,250 sats
    let balance_2: u64 = operation(
        balance_1,
        Right((50000, witness::BROKER_FEE_BP))
    );
    assert!(jet::eq_64(balance_2, 146250))
}
